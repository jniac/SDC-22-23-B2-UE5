{"version":3,"file":"static/js/602.6e15a324.chunk.js","mappings":"yIAiDO,SAASA,EAAcC,GAC5B,OAAO,IAAIC,SAAa,SAAAC,GAAO,OAAIC,uBAAsB,kBAAMD,EAAQF,EAAM,GAAC,GAChF,C,aChDaI,EAAqB,WAAsB,IAArBC,EAAK,gEAAG,EAAK,IACxCC,EAAMD,EAAQ,GACdE,EAAQ,IAAIC,cAAcF,GAC1BG,EAAM,SAACC,EAAeV,GAC1B,GAAIU,EAAQ,GAAKA,GAASL,EACxB,MAAM,IAAIM,MAAM,mBAAD,OAAoBD,EAAK,MAE1C,IAAME,EAAIC,KAAKC,MAAMJ,EAAQ,IACvBK,EAAIL,EAAY,GAAJE,EACZI,EAAIT,EAAMK,GAChBL,EAAMK,GAAKZ,EACPgB,EAAKC,OAAO,IAAMA,OAAOF,GACzBC,IAAMC,OAAO,IAAMA,OAAOF,GAChC,EACMG,EAAM,SAACR,GACX,GAAIA,EAAQ,GAAKA,GAASL,EACxB,MAAM,IAAIM,MAAM,mBAAD,OAAoBD,EAAK,MAE1C,IAAME,EAAIC,KAAKC,MAAMJ,EAAQ,IACvBK,EAAIL,EAAY,GAAJE,EAElB,OADUL,EAAMK,GACHK,OAAO,IAAMA,OAAOF,IAAOE,OAAO,EACjD,EACA,MAAO,CAAEC,IAAAA,EAAKT,IAAAA,EAChB,ECkBAU,OAAOC,OAAOC,OAAQ,CAAEC,WAzCC,WAAsB,IAArBjB,EAAK,gEAAG,EAAK,IAC/BC,EAAMD,EAAQ,GACdkB,EAAS,IAAIC,YAAY,GACzBC,EAAU,IAAIC,aAAaH,GAC3BI,EAAS,IAAIC,eAAeL,GAC5BhB,EAAQ,IAAIC,cAAcF,GAC1BuB,EAAMZ,OAAO,GACba,EAAMb,OAAO,GACbc,EAAOd,OAAO,IAChBP,EAAQ,EACRsB,EAASf,OAAO,GACdgB,EAAwB,SAACjC,GAC7ByB,EAAQ,GACJzB,EACJ,IAAMkC,EAAWP,EAAO,GAClBf,EAAIsB,EAAWH,EACrBrB,EAAQyB,OAAOvB,GACfoB,EAASE,EAAWtB,EAAImB,CAC1B,EACMb,EAAM,SAACkB,GAGX,OAFAH,EAAsBG,IACZ7B,EAAMG,GACHoB,GAAOE,GAAWH,CACjC,EACMQ,EAAM,SAACD,GACXH,EAAsBG,GACtB,IAAMpB,EAAIT,EAAMG,GAChB4B,QAAQC,IAAI7B,SAAcM,SAAUgB,GACpCzB,EAAMG,GAASM,EAAKc,GAAOE,CAC7B,EACMQ,EAAS,SAACJ,GACdH,EAAsBG,GACtB,IAAMpB,EAAIT,EAAMG,GAChBH,EAAMG,GAASM,IAAMc,GAAOE,EAC9B,EACMvB,EAAM,SAAC2B,EAAapC,GACxB,OAAOA,EAAQqC,EAAID,GAAOI,EAAOJ,EACnC,EACA,MAAO,CAAElB,IAAAA,EAAKT,IAAAA,EAAK4B,IAAAA,EAAKG,OAAAA,EAC1B,CAEoCC,KAGpC,IAAMC,GAAU,eAAG,SAAbA,IAAU,oFACRC,EAAO,KACD,SACNC,EAAQxC,EADF,UAEHyC,EAAI,EAAE,KAAD,OAAEA,EAAIF,GAAI,iBACtB,IAASG,EAAI,EAAGA,EAAIH,EAAMG,IAClB9B,EAAI+B,EAAAA,EAAAA,OAAcC,KAAKF,GAAGE,KAAKH,GAAGI,SACpCL,EAAM1B,IAAIF,GAIhB,OADC,SACK6B,EAAIF,EAAI,OAPUE,IAAG,oDAJzBH,EAAU,IAwBVQ,EAAI,yCAAG,yFACPC,EAAY,EAAC,OACL,gBACJpD,IAAe,OAGV,OAFX2C,IACAJ,QAAQC,IAAI,OAAQY,GACpBA,IAAW,iEAGd,kBATS,mCAWVD,G","sources":["some-utils/misc/misc.ts","some-utils/math/prng/test/test-utils.ts","some-utils/math/prng/digest-test.ts"],"sourcesContent":["import { deepMapValues } from '../object'\n\nexport const waitSeconds = (seconds = 1) => new Promise(resolve => setTimeout(resolve, seconds * 1e3))\n\n/**\n * \n * @param date \n * @param offset \n * @returns \n */\nexport const getLocalISOString = (\n  date = new Date(), \n  offset = date.getTimezoneOffset(),\n) => {\n  const offsetAbs = Math.abs(offset)\n  const isoString = new Date(date.getTime() - offset * 60 * 1000).toISOString()\n  const hh = String(Math.floor(offsetAbs / 60)).padStart(2, '0')\n  const mm = String(offsetAbs % 60).padStart(2, '0')\n  return `${isoString.slice(0, -1)}${offset > 0 ? '-' : '+'}${hh}:${mm}`\n}\n\nexport function radian(x: number): number\nexport function radian(arr: [number, number]): [number, number]\nexport function radian(arr: [number, number, number]): [number, number, number]\nexport function radian(arr: number[]): number[]\nexport function radian(x: any): any {\n  if (typeof x === 'number') {\n    return x * Math.PI / 180\n  }\n  return deepMapValues(x, {\n    number: x => x * Math.PI / 180,\n  }, { clone: true })\n}\n\nexport function degree(x: number): number\nexport function degree(arr: [number, number]): [number, number]\nexport function degree(arr: [number, number, number]): [number, number, number]\nexport function degree(arr: number[]): number[]\nexport function degree(x: any): any {\n  if (typeof x === 'number') {\n    return x * 180 / Math.PI\n  }\n  return deepMapValues(x, {\n    number: x => x * 180 / Math.PI,\n  }, { clone: true })\n}\n\nexport function waitNextFrame(): Promise<void>\nexport function waitNextFrame<T>(value: T): Promise<T>\nexport function waitNextFrame(value?: any) {\n  return new Promise<any>(resolve => requestAnimationFrame(() => resolve(value)))\n}","/**\n * Create a store that can store up to 2^32 booleans by storing the values into big int.\n */\nexport const createBooleanStore = (count = 2 ** 32) => {\n  const len = count / 64\n  const array = new BigInt64Array(len)\n  const set = (index: number, value: boolean) => {\n    if (index < 0 || index >= count) {\n      throw new Error(`Invalid index: \"${index}\"`)\n    }\n    const i = Math.floor(index / 64)\n    const f = index - i * 64\n    const n = array[i]\n    array[i] = value\n      ? n | (BigInt(1) << BigInt(f))\n      : n & ~(BigInt(1) << BigInt(f))\n  }\n  const get = (index: number) => {\n    if (index < 0 || index >= count) {\n      throw new Error(`Invalid index: \"${index}\"`)\n    }\n    const i = Math.floor(index / 64)\n    const f = index - i * 64\n    const n = array[i]\n    return (n & (BigInt(1) << BigInt(f))) > BigInt(0)\n  }\n  return { get, set }\n}\n","import { waitNextFrame } from '../../misc'\nimport { digest } from './digest'\nimport { createBooleanStore } from './test/test-utils'\n\nconst createFloatStore = (count = 2 ** 32) => {\n  const len = count / 64\n  const buffer = new ArrayBuffer(8)\n  const float64 = new Float64Array(buffer)\n  const uint64 = new BigUint64Array(buffer)\n  const array = new BigInt64Array(len)\n  const bi0 = BigInt(0)\n  const bi1 = BigInt(1)\n  const bi64 = BigInt(64)\n  let index = 0\n  let offset = BigInt(0)\n  const computeIndexAndOffset = (value: number) => {\n    float64[0\n    ] = value\n    const bigIndex = uint64[0]\n    const i = bigIndex / bi64\n    index = Number(i)\n    offset = bigIndex - i * bi64\n  }\n  const get = (key: number) => {\n    computeIndexAndOffset(key)\n    const n = array[index]\n    return (n & (bi1 << offset)) > bi0\n  }\n  const add = (key: number) => {\n    computeIndexAndOffset(key)\n    const n = array[index]\n    console.log(index, typeof n, typeof offset)\n    array[index] = n | (bi1 << offset)\n  }\n  const remove = (key: number) => {\n    computeIndexAndOffset(key)\n    const n = array[index]\n    array[index] = n & ~(bi1 << offset)\n  }\n  const set = (key: number, value: number) => {\n    return value ? add(key) : remove(key)\n  }\n  return { get, set, add, remove }\n}\n\nObject.assign(window, { floatStore: createFloatStore() })\n\n\nconst testGrid2D = function* () {\n  const size = 0x1_000\n  const max = 0x1_000_000\n  const store = createBooleanStore(max)\n  for (let y = 0; y < size; y++) {\n    for (let x = 0; x < size; x++) {\n      const n = digest.init().next(x).next(y).result()\n      if (store.get(n)) {\n\n      }\n    }\n    yield y / size\n  }\n}\n\n/**\n * Can't remember what's going on here. It's about test about digest with 2D \n * numbers. But it's not finished. Commit / pushed as is.\n * \n * Just a note since I can still remember that:\n * The difficulty is about storing huge amout of test, very huuuuuge (about \n * 4 billions / 2^32 ?). So a boolean store baked through bitwise operation in \n * bigint stored in BigInt64Array is used here... or somewhere else! \n */\nconst test = async () => {\n  let loopCount = 0\n  while (true) {\n    await waitNextFrame()\n    testGrid2D()\n    console.log('loop', loopCount)\n    loopCount++\n    break\n  }\n}\n\ntest()\n\n"],"names":["waitNextFrame","value","Promise","resolve","requestAnimationFrame","createBooleanStore","count","len","array","BigInt64Array","set","index","Error","i","Math","floor","f","n","BigInt","get","Object","assign","window","floatStore","buffer","ArrayBuffer","float64","Float64Array","uint64","BigUint64Array","bi0","bi1","bi64","offset","computeIndexAndOffset","bigIndex","Number","key","add","console","log","remove","createFloatStore","testGrid2D","size","store","y","x","digest","next","result","test","loopCount"],"sourceRoot":""}